# NextJs 한장정리

- ****Getting Started****
    
    <aside>
    ❤️‍🔥 [learn course.](https://nextjs.org/learn/basics/create-nextjs-app) 에서 시작하는 것 추천
    
    Node.js ver > 12.22.0
    
    시작 명령어 : npx create-next-app@latest (--typescript)
    같이 설치 : npm install next react react-dom
    1. next
    2. react
    3. react-dom
    
    개발 단계는 4가지로 구성 각각 명령어 존재
    1. dev
    2. build
    3. start
    4. lint
    
    각 파일의 확장자는 `.js` `.jsx` `.ts` `.tsx`
    
    4가지 특징
    - 자동 컴파일 및 번들링(웹 팩 및 베이블 포함)
    - 반응 빠른 새로 고침
    - ./page의 정적 생성 및 서버 측 렌더링/
    - 정적 파일 서비스. ./public/가 /에 매핑되었습니다.
    
    </aside>
    
- **Basic Features**
    - ****Pages****
        
        <aside>
        ❤️‍🔥 페이지들은 기본적으로 `React Component` 임.
        또 각 페이지들은 파일 이름으로 라우팅이 된다.
        
        > 결론 : 페이지 생성방법 3가지 
        → `getStaticProps`, `getStaticPaths`, `getServerSideProps`
        > 
        - [다이나믹 라우팅 지원](https://nextjs.org/docs/routing/dynamic-routes)
        
        For example, if you create a file called `pages/posts/[id].js`
        , then it will be accessible at `posts/1`, `posts/2`
        
        > 프리-렌더링
        → 모든 페이지 마다 HTML 을 사전에 만들어둔다.
        > 
        - ***[Two forms of Pre-rendering](https://nextjs.org/docs/basic-features/pages#two-forms-of-pre-rendering)
        → 두가지 방식이 있다. 정적생성, 서버사이드 렌더링. 둘이 섞어서 쓸 수 있다.**
        - **[Server-side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)**: The HTML is generated on **each request**.
        - **[Static Generation (Recommended)](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)**: The HTML is generated at **build time** and will be reused on each request.
        
        You can create a "hybrid" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.
        
        정적 파일 생성이 CDN 도 쓰고 cache 도 쓸 수 있어서 추천 이지만 server-side 방식으로만 가능한 것들도 있어서 섞어서 써야한다.
        또 어떤 페이지는 Client-side Rendering 써줘야한다.
        
        ### 데이터를 가지고 정적 사이트를 만드는 방법
        
        - Your page **content** depends on external data: Use `getStaticProps`.
            - To fetch this data on pre-render, Next.js allows you to `export`
             an `async` function called `getStaticProps` from the same file.
            - This function gets called at build time and lets you pass fetched data to the page's `props`on pre-render.
        - Your page **paths** depend on external data: Use `getStaticPaths` (usually in addition to `getStaticProps`).****
            - So your page **paths** that are pre-rendered depend on external data**.**
            - To handle this, Next.js lets you `export` an `async` function called `getStaticPaths` from a dynamic page (`pages/posts/[id].js` in this case).
            - This function gets called at build time and lets you specify which paths you want to pre-render.
            
        
        정적 생성이 좋지 않을 때 : 데이터가 빈번하게 업데이트 되는 페이지는 사용하지 않는 것이 좋다. 특히 모든 요청에 페이지 컨텐츠가 변하는 페이지 일 경우에는
        
        ### ****[Server-side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)****
        
        As you can see, `getServerSideProps` is similar to `getStaticProps`, but the difference is that `getServerSideProps` is run on every request instead of on build time.
        
        </aside>
        
    - ****Data Fetching****
        - ****Overview****
            
            데이터 패칭 에 따른 3가지 렌더링 방법 
            
            **`Server-side Rendering`**
            
            **`Static Generation`**
            
            **`Incremental Static Regeneration`**: enables you to use static-generation on a per-page basis, **without needing to rebuild the entire site**
            
        - ****getServerSideProps****
            
            <aside>
            ❤️‍🔥 이 함수는 무조건 서버에서 동작한다. 브라우저에서는 동작하지 않는다.
            
            </aside>
            
            > ****[When does getServerSideProps run](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props#when-does-getserversideprops-run) : 언제 함수가 돌아가는지?**
            > 
            - 무조건 서버에서 돌아가며 브라우저에서는 절대 안 돌아간다.
                - 직접 들어올때 : prop을 리턴하며 실행된다.
                - 라우트 통해서 들어올 때 : 서버에서 해당 함수를 실행한다.
            - 리턴 값이 `JSON` 형식인데, 이 데이터가 페이지 렌더링 될 때 사용된다.
            - 페이지 컴포넌트에서만 `export` 할 수 있으며, 페이지가 아닌 곳에서는 할 수 없다.
            - 이 함수는 일반 함수형으로만 `export` 되어야 한다.
            - `[getServerSideProps` API reference](https://nextjs.org/docs/api-reference/data-fetching/get-server-side-props)
            
            > ****[When should I use getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props#when-should-i-use-getserversideprops) : 언제 이 함수를 사용해야 하나요?**
            > 
            - 데이터가 request 시에 반드시 가져와져야 하는 곳에서만 사용해야 한다.
            - [Time to First Byte (TTFB)](https://web.dev/ttfb/) will be higher than getStaticProps because the server must compute the result on every request, and the result can only be cached by a CDN using cache-control headers (which could require extra configuration).
                - TTFB 라는게 있는데, 서버에서 먼저 캐쉬 컨트롤 기능이 있어서 그게 먼저라고 함.
            - 꼭 사용해야하는 경우가 아니면 Client-side 로 렌더링 하는 게 좋음
            - 판단을 해야줘야 하는 듯
            - ****[getServerSideProps or API Routes](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props#getserversideprops-or-api-routes)→ 다른 API 호출 내부 호출처럼 마스킹 기능**
            
            > ****[Fetching data on the client side](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props#fetching-data-on-the-client-side) : 유저 정보 페이지 같은 SEO 사용하면 안되는 곳에 사용된다.**
            > 
            
        - ****getStaticPaths****
            
            <aside>
            ❤️‍🔥 사용조건 :  `다이나믹 라우팅`, `getStaticProps`
            
            </aside>
            
            - 기억 ! : 이 함수는 `getStaticProps`와 반드시 함께 쓰여야 한다. `getServerSideProps` 와는 절대 함께 쓰일 수 없다.
            
            > ****[When should I use getStaticPaths?](https://nextjs.org/docs/basic-features/data-fetching/get-static-paths#when-should-i-use-getstaticpaths) → 언제 이 함수를 써야할까?**
            > 
            - 다이나믹 라우팅 사용하면서 데이터가 ,,,
                - CMS 서비스에서 올때
                - 데이터베이스에서 올 때
                - 파일시스템에서 올 때
                - 공용 캐시에서 올 때 (유저 특정하지 않음)
                - SEO 위해서 반드시 미리 렌더링 해줘야할 때
            
            > ****[When does getStaticPaths run](https://nextjs.org/docs/basic-features/data-fetching/get-static-paths#when-does-getstaticpaths-run) → 언제 이 함수가 돌아가나?**
            > 
            - 서버에서 빌드 될 때만 생성된다.
            - 만약에   ISR 사용할 꺼면 요청에 따라서 백그라운드에서 돌아갈 수 있지만, 여전히 서버에서 작동한다.
            
            > ****[Where can I use getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching/get-static-paths#where-can-i-use-getstaticpaths) → 어디서 사용해야할까?**
            > 
            - 페이지 에서만 `export` 할 수 있따.
            - 일반 함수형으로 사용해야 한다는 점 명심 !
        - ****getStaticProps****
            
            ```jsx
            export async function getStaticProps(context) {
              return {
                props: {}, // will be passed to the page component as props
              }
            }
            ```
            
            > ****[When should I use getStaticProps?](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#when-should-i-use-getstaticprops) → 언제 이 함수를 사용해야할까?**
            > 
            - CMS 서비스에서 올때
            - 파일시스템에서 올 때
            - 공용 캐시에서 올 때 (유저 특정하지 않음)
            - SEO 위해서 반드시 미리 렌더링 해줘야할 때
            
            → ****getStaticPaths**** 와 거의 비슷함.(데이터베이스 빼고)
            
            - 이 함수는 빌드타임 시에만 작동하고, 들어오는 요청을 받아들이지 않기 때문에 정말 필요하면 `미들웨어`를 추가해서 사용해야 한다.
            
            > ****[Write server-side code directly](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#write-server-side-code-directly) 
            → 이 함수는 절대로 브라우저로 보내지지 않는다. 심지어 번들링도 안됨. 그래서 db쿼리 써도됨**
            > 
            
            > ****[Statically generates both HTML and JSON](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#statically-generates-both-html-and-json)
            → 이 페이지는 HTML도 만들지만 JSON 도 만든다(리턴값)**
            > 
            
            > ****[Where can I use getStaticProps](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#where-can-i-use-getstaticprops) → 어디서 이 함수를 사용할까?**
            > 
            - 페이지 에서만 사용한다.
            - 그리고 일반 함수형으로 써줘야 한다.
            
            > ****[Preview Mode](https://nextjs.org/docs/basic-features/data-fetching/get-static-props#preview-mode) → 만들어지는 파일 보고 싶은 순간에는 프리뷰 모드라는 걸 사용하면 된다.**
            > 
            
        - ****Incremental Static Regeneration****
            - next.js 는 사이트가 빌드 된 후에도 정적 페이지를 만들거나 업데이트할 기회를 준다 !
            - 이 기능 이용하려면 `getStaticProps` 에서 `return` 키 값으로 `revalidate` 를 주면 된다.
            
            ```jsx
            function Blog({ posts }) {
              return (
                <ul>
                  {posts.map((post) => (
                    <li key={post.id}>{post.title}</li>
                  ))}
                </ul>
              )
            }
            
            // This function gets called at build time on server-side.
            // It may be called again, on a serverless function, if
            // revalidation is enabled and a new request comes in
            export async function getStaticProps() {
              const res = await fetch('https://.../posts')
              const posts = await res.json()
            
              return {
                props: {
                  posts,
                },
                // Next.js will attempt to re-generate the page:
                // - When a request comes in
                // - At most once every 10 seconds
                revalidate: 10, // In seconds
              }
            }
            
            // This function gets called at build time on server-side.
            // It may be called again, on a serverless function, if
            // the path has not been generated.
            export async function getStaticPaths() {
              const res = await fetch('https://.../posts')
              const posts = await res.json()
            
              // Get the paths we want to pre-render based on posts
              const paths = posts.map((post) => ({
                params: { id: post.id },
              }))
            
              // We'll pre-render only these paths at build time.
              // { fallback: blocking } will server-render pages
              // on-demand if the path doesn't exist.
              return { paths, fallback: 'blocking' }
            }
            
            export default Blog
            ```
            
            - 작동방식 (파파고 돌림) → ISR 은 캐시가 얼마나 글로벌하고 롤백을 잘 다루느냐에 달렸다.
                - 빌드 시 미리 렌더링된 페이지에 요청을 하면 처음에는 캐시된 페이지가 표시됩니다.
                - 초기 요청 후와 10초 전에 페이지에 대한 요청도 즉시 캐시됩니다.
                - 10초 후 다음 요청이 캐시된(스틸) 페이지를 계속 표시합니다.
                - 다음.js는 백그라운드에서 페이지 재생성을 트리거합니다.
                - 페이지가 성공적으로 생성되면 Next.js는 캐시를 무효화하고 업데이트된 페이지를 표시합니다. 백그라운드 재생이 실패해도 이전 페이지는 변경되지 않습니다.
                - 생성되지 않은 경로에 대한 요청이 작성되면, Next.js는 첫번째 요청 시 페이지를 서버 렌더링합니다. 이후 요청은 캐시의 정적 파일을 처리합니다.
            
        - ****Client-side data fetching****
            - SEO 필요없을 때, 데이터 패치 안해도 될 떄, 업데이트 빈번하게 안할 때 사용
            - 컴포넌트 레벨에서 데이터 패칭 사용한다.
            - 이 기능사용하면 성능과 페이지 로드 속도에 영향을 미칠 수 있다. 캐시가 안되고 컴포넌트 마운트 때마다 API 호출하기 때문임
            - 그냥 `React` 이용하는 거랑 같음
                - `useEffect`, `SWR`
                
    - ****Built-In CSS Support****
        
        <aside>
        ❤️‍🔥 CSS 임포트 하자.
        
        </aside>
        
        > ****[Adding a Global Stylesheet](https://nextjs.org/docs/basic-features/built-in-css-support#adding-a-global-stylesheet) →** import the CSS file within `pages/_app.js`
        > 
        
        ```jsx
        import '../styles.css'
        
        // This default export is required in a new `pages/_app.js` file.
        export default function MyApp({ Component, pageProps }) {
          return <Component {...pageProps} />
        }
        ```
        
        > ****[Import styles from `node_modules`](https://nextjs.org/docs/basic-features/built-in-css-support#import-styles-from-node_modules) → next > 9.5.4 부터 지원**
        > 
        
        > ****[Adding Component-Level CSS](https://nextjs.org/docs/basic-features/built-in-css-support#adding-component-level-css) →** the `[name].module.css` file naming convention.
        > 
        
        > ****[Sass Support](https://nextjs.org/docs/basic-features/built-in-css-support#sass-support) → .sass .scss .module.sass .module.scss 다 지원**
        > 
        
        ```bash
        npm install sass // 설치 정돈 하자
        ```
        
        > ****[Customizing Sass Options](https://nextjs.org/docs/basic-features/built-in-css-support#customizing-sass-options) →** so by using `sassOptions` in `next.config.js`
        > 
        
        ```jsx
        const path = require('path')
        
        module.exports = {
          sassOptions: {
            includePaths: [path.join(__dirname, 'styles')],
          },
        }
        ```
        
        > ****[Sass Variables](https://nextjs.org/docs/basic-features/built-in-css-support#sass-variables) → Next.js supports Sass variables exported from CSS Module files.**
        > 
        
        > ****[CSS-in-JS](https://nextjs.org/docs/basic-features/built-in-css-support#css-in-js) → 예시가 많음, 쓰고 싶은대로 다 써도됨**
        > 
        > - [Styled JSX](https://github.com/vercel/next.js/tree/canary/examples/with-styled-jsx)
        > - [Styled Components](https://github.com/vercel/next.js/tree/canary/examples/with-styled-components)
        > - [Emotion](https://github.com/vercel/next.js/tree/canary/examples/with-emotion)
        
    - ****Layouts****
        
        <aside>
        ❤️‍🔥 페이지 분해해서 나누기,,
        Many of these components are often reused between pages
        
        </aside>
        
        > ****[Single Shared Layout with Custom App](https://nextjs.org/docs/basic-features/layouts#single-shared-layout-with-custom-app) → 앱에 레이아웃 하나일 때**
        > 
        
        ```bash
        // pages/_app.js
        
        import Layout from '../components/layout'
        
        export default function MyApp({ Component, pageProps }) {
          return (
            <Layout>
              <Component {...pageProps} />
            </Layout>
          )
        }
        ```
        
        > ****[Per-Page Layouts](https://nextjs.org/docs/basic-features/layouts#per-page-layouts) → 앱에 레이아웃 여러개 필요할 때,,,** 
        you can add a property `getLayout` to your page,
        이거 쓰면 각 페이지를 SPA 처럼 관리할 수 있따. GOOD ~!
        > 
        - 코드
            
            ```jsx
            // pages/index.js
            
            import Layout from '../components/layout'
            import NestedLayout from '../components/nested-layout'
            
            export default function Page() {
              return {
                /** Your content */
              }
            }
            
            Page.getLayout = function getLayout(page) {
              return (
                <Layout>
                  <NestedLayout>{page}</NestedLayout>
                </Layout>
              )
            }
            ```
            
            ```jsx
            // pages/_app.js
            
            export default function MyApp({ Component, pageProps }) {
              // Use the layout defined at the page level, if available
              const getLayout = Component.getLayout || ((page) => page)
            
              return getLayout(<Component {...pageProps} />)
            }
            ```
            
        
        > ****[With TypeScript](https://nextjs.org/docs/basic-features/layouts#with-typescript) → 타입스크립트 쓸 때는 getLayout 함수를 포함하는 페이지 타입을 만들어주고 시작해야한다.**
        > 
        - 코드
            
            ```tsx
            // pages/index.tsx
            
            import type { ReactElement } from 'react'
            import Layout from '../components/layout'
            import NestedLayout from '../components/nested-layout'
            
            export default function Page() {
              return {
                /** Your content */
              }
            }
            
            Page.getLayout = function getLayout(page: ReactElement) {
              return (
                <Layout>
                  <NestedLayout>{page}</NestedLayout>
                </Layout>
              )
            }
            ```
            
            ```tsx
            // pages/_app.tsx
            
            import type { ReactElement, ReactNode } from 'react'
            import type { NextPage } from 'next'
            import type { AppProps } from 'next/app'
            
            type NextPageWithLayout = NextPage & {
              getLayout?: (page: ReactElement) => ReactNode
            }
            
            type AppPropsWithLayout = AppProps & {
              Component: NextPageWithLayout
            }
            
            export default function MyApp({ Component, pageProps }: AppPropsWithLayout) {
              // Use the layout defined at the page level, if available
              const getLayout = Component.getLayout ?? ((page) => page)
            
              return getLayout(<Component {...pageProps} />)
            }
            ```
            
        
        > ****[Data Fetching](https://nextjs.org/docs/basic-features/layouts#data-fetching) → 이게 페이지는 아니라서 관련 함수는 못 쓰지만 useEffect 랑 SWR 이용해서 사용가능하다.**
        > 
    - ****Image Component and Image Optimization****
        
        <aside>
        ❤️‍🔥 It includes a variety of built-in performance optimizations to help you achieve good [Core Web Vitals](https://nextjs.org/learn/seo/web-performance). These scores are an important measurement of user experience on your website, and are [factored into Google's search rankings](https://nextjs.org/learn/seo/web-performance/seo-impact).
        
        </aside>
        
        - 이미지 컴포넌트 최적화를 도와준다.
            - 향상된 성능: 최신 이미지 형식을 사용하여 각 장치에 대해 항상 올바른 크기의 이미지 제공
            - 시각적 안정성: 누적 레이아웃 이동 방지
            - 더 빠른 페이지 로드: 이미지는 뷰포트에 들어갈 때만 로드되며, 블러업 플레이스홀더(옵션)가 있습니다.
            - 자산 유연성: 원격 서버에 저장된 이미지의 경우에도 주문형 이미지 크기 조정
        - `import Image from 'next/image'`
        
        > ****[Local Images](https://nextjs.org/docs/basic-features/image-optimization#local-images) → 경로 접근해서 받아와야함**
        > 
        - Dynamic `await import()` or `require()` are *not* supported. The `import` must be static so it can be analyzed at build time.
        - 크기랑 높이는 next 에서 알아서!! 결정한다. 설정 따로 불가능
        
        > ****[Remote Images](https://nextjs.org/docs/basic-features/image-optimization#remote-images)****
        > 
        - 값은 스트링 이어야 한다. 왜냐하면 nextjs는 빌드될까 원격주소로 붙을 수 없기 때문이다.
        - 그래서 높이, 넓이, 블러 할 사진 이미지 링크도 있어야 함
        
        > 도메인
        > 
        - 이미지 최적화 요소 쓰면서도 원격 이미지를 쓰고 싶을 때가 있지
        - 그럴땐 loader component를 두어라.
        - 또 아무 도메인에서나 들어오면 안되기 때문에 익명 유저한테 보호하기 위해서는 next.config.js 파일에 이미지 도메인 설명을 해주어야한다.
        
        > Loaders
        > 
        - 로더 아키텍쳐?! 가 뭐징???
            - A loader is a function that generates the URLs for your image. It appends a root domain to your provided `src`, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automatic [srcset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset) generation, so that visitors to your site will be served an image that is the right size for their viewport.
            - Loaders can be defined per-image, or at the application level.
        
        > Priority
        > 
        - You should add the `priority` property to the image that will be the [Largest Contentful Paint (LCP) element](https://web.dev/lcp/#what-elements-are-considered) for each page
        - When you run `next dev`, you'll see a console warning if the LCP element is an `<Image>` without the `priority` property.
        
        > Image sizing
        > 
        - Because `next/image` is designed to guarantee good performance results,**must** be sized in one of three ways:
        1. Automatically, using a [static import](https://nextjs.org/#local-images)
        2. Explicitly, by including a `height` **and** `width`property
        3. Implicitly, by using `layout="fill"` which causes the image to expand to fill its parent element.
        
        > styling
        > 
        
        there are a few guidelines to keep in mind:
        
        - **Pick the correct layout mode**
        - **Target the image with className, not based on DOM structure**
        - 이미지 컴포넌트 스타일링 하는 방법은 오직 클래스네임 먹여서 모듈css로 하는 수 밖에 없음
        
    - **Font Optimization**
        
        This results in improvements to First Contentful Paint (FCP) and Largest Contentful Paint (LCP)
        
        > 사용법 : Head 또는 Document 에 적용한다
        > 
        
        > **[Disabling Optimization](https://nextjs.org/#disabling-optimization)**
        > 
    - **Static File Serving**
        
        Next.js can serve static files, like images, under a folder called `public` in the root directory.
        
        This folder is also useful for `robots.txt`, `favicon.ico`, Google Site Verification, and any other static files (including `.html`)!
        
        We recommend using a third party service like [AWS S3](https://aws.amazon.com/s3/) for persistent file storage. → 빌드타임에서만 static 이 만들어지고 그 후에 추가 또는 제거가 되지 않아서 S3 쓰는게 훨씬 났다.
        
    - ****Fast Refresh****
        
        most edits should be visible within a second, **without losing component state**
        
        > ****[How It Works](https://nextjs.org/docs/basic-features/fast-refresh#how-it-works)****
        > 
        1. you edit a file that **only exports React component(s)**
        2. you edit a file with exports that *aren't* React components, Fast Refresh will re-run both that file, and the other files importing it.
        3. you **edit a file** that's **imported by files outside of the React tree**, Fast Refresh **will fall back to doing a full reload**
            1. For example, maybe your component also exports a constant, and a non-React utility file imports it. In that case, consider migrating the constant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be solved in a similar way.
            2. 대충 상수값 export 하는 js 파일 같은 거 처리할 때 refresh 동작이 헤비하게 들어가니까 나누면 좋다는 내용
        
        > ****[Error Resilience](https://nextjs.org/docs/basic-features/fast-refresh#error-resilience) : 오류 복원력**
        > 
        1. 문법 에러 : **You will not lose component state.**
        2. 런타임 에러 : 에러 바운더리 라는거 설치하면 좀 도움이 된다고 함. 근데 조심스럽게 다루라고 함.
        
        > ****[Limitations](https://nextjs.org/docs/basic-features/fast-refresh#limitations) : 로컬상태가 안 바뀌기는 하는데, 각 파일마다 상태가 존재해서 네가지 맞춰서 해줘야함. 주의 필요 → 함수형 훅 컴포넌트 써주세요 ~**
        > 
        - Local state is not preserved for class components (only function components and Hooks preserve state).
        - The file you're editing might have *other* exports in addition to a React component.
        - Sometimes, a file would export the result of calling a higher-order component like `HOC(WrappedComponent)`. If the returned component is a class, its state will be reset.
        - Anonymous arrow functions like `export default () => <div />;` cause Fast Refresh to not preserve local component state. For large codebases you can use our `[name-default-component` codemod](https://nextjs.org/docs/advanced-features/codemods#name-default-component).
        - Sometimes you might want to *force* the state to be reset, and a component to be remounted. For example, this can be handy if you're tweaking an animation that only happens on mount. To do this, you can add `// @refresh reset` anywhere in the file you're editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit.
        
        > ****[Fast Refresh and Hooks](https://nextjs.org/docs/basic-features/fast-refresh#fast-refresh-and-hooks) : use함수 안에서 쓰이는 변수들은 리프레쉬 될 때 초기화 된다. 아무튼 조심하셈 ,,,**
        > 
        
        가능한 경우 빠른 새로 고침은 편집 사이에 구성 요소의 상태를 보존하려고 시도합니다. 특히 useState 및 useRef는 해당 인수나 후크 호출 순서를 변경하지 않는 한 이전 값을 유지합니다.
        
        useEffect, useMemo 및 useCallback과 같은 종속성이 있는 후크는 항상 빠른 새로 고침 중에 업데이트됩니다. 빠른 새로 고침이 수행되는 동안에는 종속성 목록이 무시됩니다.
        
        예를 들어, useMemo(() => x * 2, [x])를 사용하여 편집하면 x(종속성)가 변경되지 않았더라도 다시 실행됩니다. React가 그렇게 하지 않으면 편집한 내용이 화면에 반영되지 않습니다!
        
        때때로, 이것은 예상치 못한 결과로 이어질 수 있습니다. 예를 들어 종속성 배열이 비어 있는 useEffect도 Fast Refresh 중에 한 번 다시 실행됩니다.
        
        그러나 fast refresh 없이 useEffect를 자주 다시 실행할 수 있는 코드를 작성하는 것이 좋습니다. 나중에 이 기능에 새로운 종속성을 도입하는 것이 더 쉬울 것이며, 이 기능은 Response Strict Mode를 통해 구현될 수 있도록 적극 권장됩니다.
        
    - ****ESLint****
        
        린트 처리 3개 **`Strict` `Base` `Cancel`**
        
        Strict mode : `"next/core-web-vitals"` 를 사용한다.
        
        `.eslintrc.json` root 폴더에 생성.
        
        > ****[ESLint Config](https://nextjs.org/docs/basic-features/eslint#eslint-config)****
        > 
        - `[eslint-plugin-react](https://www.npmjs.com/package/eslint-plugin-react)`
        - `[eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)`
        - `[eslint-plugin-next](https://www.npmjs.com/package/@next/eslint-plugin-next)`
        - `[eslint-config-next](https://www.npmjs.com/package/eslint-config-next)` : 이것은 next.config.js의 구성보다 우선합니다.
        
        > ****[ESLint Plugin](https://nextjs.org/docs/basic-features/eslint#eslint-plugin)****
        > 
        
        > ****[Custom Settings](https://nextjs.org/docs/basic-features/eslint#custom-settings) : 모노레포에서 NextJs 린트 설정할 때 `rootDir` 잡아줘야한다.**
        > 
        
        > ****[Linting Custom Directories and Files](https://nextjs.org/docs/basic-features/eslint#linting-custom-directories-and-files) 
        :** By default, Next.js will run ESLint for all files in the `pages/`, `components/`, and `lib/` directories.
        > 
        
        > ****[Caching](https://nextjs.org/docs/basic-features/eslint#caching) : 린트도 캐시를 하는데, `.next/cache` 에 저장되고 특정 폴더에 저장할 수도 있다.**
        > 
        
        > ****[Disabling Rules](https://nextjs.org/docs/basic-features/eslint#disabling-rules) :** `.eslintrc` 에서 룰 비활성 가능
        > 
        
        > ****[Core Web Vitals](https://nextjs.org/docs/basic-features/eslint#core-web-vitals) :** `"next/core-web-vitals"`
        Web Vitals는 웹에서 우수한 사용자 경험을 제공하는 데 필수적인 품질 신호에 대한 통합 지침을 제공하기 위한 Google의 이니셔티브입니다.
        > 
        
        > ****[Usage With Other Tools](https://nextjs.org/docs/basic-features/eslint#usage-with-other-tools)**
        > 
        - ****[Prettier](https://nextjs.org/docs/basic-features/eslint#prettier) :** We recommend including [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) in your ESLint config to make ESLint and Prettier work together.
            
            ```bash
            npm install --save-dev eslint-config-prettier
            # or
            yarn add --dev eslint-config-prettier
            ```
            
        - ****[lint-staged](https://nextjs.org/docs/basic-features/eslint#lint-staged) :** `.lintstagedrc.js` file in the root of your project in order to specify usage of the `--file` flag.
        
        > ****[Migrating Existing Config](https://nextjs.org/docs/basic-features/eslint#migrating-existing-config) : 이미 존재할 떄 해결방법 (리팩토링 할 떄 필요한듯)**
        > 
        
        > ****[Additional Configurations](https://nextjs.org/docs/basic-features/eslint#additional-configurations) : ESlint 랑 next lint 랑 두개 같이 쓰고 싶을 때**
        > 
        
    - ****TypeScript****
        
        > ****[Existing projects](https://nextjs.org/docs/basic-features/typescript#existing-projects)****
        > 
        - To get started in an existing project, create an empty `tsconfig.json` file in the root folder: `touch tsconfig.json`
        - You can also provide a relative path to a tsconfig.json file by setting `typescript.tsconfigPath` prop inside your `next.config.js` file.
        - Starting in `v12.0.0`, Next.js uses [SWC](https://nextjs.org/docs/advanced-features/compiler) by default to compile TypeScript and TSX for faster builds.
            - Next.js will use Babel to handle TypeScript if `.babelrc`
             is present. This has some [caveats](https://babeljs.io/docs/en/babel-plugin-transform-typescript#caveats) and some [compiler options are handled differently](https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options).
        - You're now ready to start converting files from `.js` to `.tsx` and leveraging the benefits of TypeScript!
            - A file named `next-env.d.ts` will be created in the root of your project. This file ensures Next.js types are picked up by the TypeScript compiler. **You cannot remove it or edit it** as it can change at any time.
            - TypeScript `strict` mode is turned off by default. When you feel comfortable with TypeScript, it's recommended to turn it on in your `tsconfig.json`.
            - Instead of editing `next-env.d.ts`, you can include additional types by adding a new file e.g. `additional.d.ts` and then referencing it in the `[include](https://www.typescriptlang.org/tsconfig#include)` array in your `tsconfig.json`.
        
        > ****[Static Generation and Server-side Rendering](https://nextjs.org/docs/basic-features/typescript#static-generation-and-server-side-rendering)****
        > 
        
        ```jsx
        import { GetStaticProps, GetStaticPaths, GetServerSideProps } from 'next'
        
        export const getStaticProps: GetStaticProps = async (context) => {
          // ...
        }
        
        export const getStaticPaths: GetStaticPaths = async () => {
          // ...
        }
        
        export const getServerSideProps: GetServerSideProps = async (context) => {
          // ...
        }
        ```
        
        If you're using `getInitialProps`, you can [follow the directions on this page](https://nextjs.org/docs/api-reference/data-fetching/get-initial-props#typescript).
        
        > ****[API Routes](https://nextjs.org/docs/basic-features/typescript#api-routes)****
        > 
        
        ```jsx
        import type { NextApiRequest, NextApiResponse } from 'next'
        
        export default (req: NextApiRequest, res: NextApiResponse) => {
          res.status(200).json({ name: 'John Doe' })
        }
        ```
        
        ```jsx
        import type { NextApiRequest, NextApiResponse } from 'next'
        
        type Data = {
          name: string
        }
        
        export default (req: NextApiRequest, res: NextApiResponse<Data>) => {
          res.status(200).json({ name: 'John Doe' })
        }
        ```
        
        > ****[Custom `App`](https://nextjs.org/docs/basic-features/typescript#custom-app)**
        > 
        
        ```jsx
        // import App from "next/app";
        import type { AppProps /*, AppContext */ } from 'next/app'
        
        function MyApp({ Component, pageProps }: AppProps) {
          return <Component {...pageProps} />
        }
        
        // Only uncomment this method if you have blocking data requirements for
        // every single page in your application. This disables the ability to
        // perform automatic static optimization, causing every page in your app to
        // be server-side rendered.
        //
        // MyApp.getInitialProps = async (appContext: AppContext) => {
        //   // calls page's `getInitialProps` and fills `appProps.pageProps`
        //   const appProps = await App.getInitialProps(appContext);
        
        //   return { ...appProps }
        // }
        
        export default MyApp
        ```
        
        > ****[Path aliases and baseUrl](https://nextjs.org/docs/basic-features/typescript#path-aliases-and-baseurl)****
        > 
        
        Next.js automatically supports the `tsconfig.json` `"paths"` and `"baseUrl"` options.
        
        > ****[Type checking next.config.js](https://nextjs.org/docs/basic-features/typescript#type-checking-nextconfigjs)****
        > 
        
        The `next.config.js` file must be a JavaScript file as it does not get parsed by Babel or TypeScript, however you can add some type checking in your IDE using JSDoc as below:
        
        ```jsx
        // @ts-check
        
        /**
         * @type {import('next').NextConfig}
         **/
        const nextConfig = {
          /* config options here */
        }
        
        module.exports = nextConfig
        ```
        
        > ****[Incremental type checking](https://nextjs.org/docs/basic-features/typescript#incremental-type-checking) : 버전 업 되면서 성능 더 좋아졌다는 이야기임**
        > 
        
    - ****Environment Variables****
        
        > built-in support for environment variables
        > 
        - [Use `.env.local` to load environment variables](https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables)
        - [Expose environment variables to the browser by prefixing with `NEXT_PUBLIC_`](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)
        
        > ****[Loading Environment Variables](https://nextjs.org/docs/basic-features/environment-variables#loading-environment-variables)****
        > 
        
        ```
        DB_HOST=localhost
        DB_USER=myuser
        DB_PASS=mypassword
        ```
        
        This loads `process.env.DB_HOST`, `process.env.DB_USER`, and `process.env.DB_PASS`
         into the Node.js environment automatically allowing you to use them in [Next.js data fetching methods](https://nextjs.org/docs/basic-features/data-fetching/overview) and [API routes](https://nextjs.org/docs/api-routes/introduction).
        
        → 빌드 타임에서 사용되니까 이건 텍스트다. 따라서 자바스크립트 객체가 아니다. 탈구조화? 쓰지마셈 `destructuring`
        
        $변수명 으로 위에 있는 값 그대로 가져올 수 있다. “$” 를 쓰고 싶으면 \ 를 같이 써줄 것 !
        
        `.env` 파일 `/src` 밑으로 파일 넣지마세요
        
        > ****[Exposing Environment Variables to the Browser](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)****
        > 
        
        In order to expose a variable to the browser you have to prefix the variable with `NEXT_PUBLIC_`.
        
        > ****[Default Environment Variables](https://nextjs.org/docs/basic-features/environment-variables#default-environment-variables)****
        > 
        
        > ****[Environment Variables on Vercel](https://nextjs.org/docs/basic-features/environment-variables#environment-variables-on-vercel)****
        > 
        
        If you've configured [Development Environment Variables](https://vercel.com/docs/environment-variables#development-environment-variables) you can pull them into a `.env.local` for usage on your local machine using the following command: `vercel env pull .env.local`
        
        When using the Vercel CLI to deploy make sure you add a `[.vercelignore](https://vercel.com/guides/prevent-uploading-sourcepaths-with-vercelignore?query=vercelignore#allowlist)` that includes files that should not be uploaded, generally these are the same files included in `.gitignore`.****
        
        > ****[Test Environment Variables](https://nextjs.org/docs/basic-features/environment-variables#test-environment-variables)****
        > 
        
        you can do the same with a `.env.test` file for the `testing` environment (though this one is not as common as the previous two).
        
        `.env.local` won't be loaded, as you expect tests to produce the same results for everyone.
        
        `loadEnvConfig`
        
        ```
        // The below can be used in a Jest global setup file or similar for your testing set-up
        import { loadEnvConfig } from '@next/env'
        
        export default async () => {
          const projectDir = process.cwd()
          loadEnvConfig(projectDir)
        }
        ```
        
        > ****[Environment Variable Load Order](https://nextjs.org/docs/basic-features/environment-variables#environment-variable-load-order)****
        > 
        
        `NODE_ENV=production`
        
        - `.env.production.local`
        - `.env.local`
        - `.env.production`
        - `.env`
        
        `NODE_ENV=development`
        
        - `.env.development.local`
        - `.env.local`
        - `.env.development`
        - `.env`
        
        `NODE_ENV=test`
        
        - `.env.test.local`
        - `.env.test`
        - `.env`
        
    - ****Supported Browsers and Features****
        
        > ****[Polyfills](https://nextjs.org/docs/basic-features/supported-browsers-features#polyfills) : 웹 개발에서 기능을 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 뜻한다.**
        > 
        - ****[Server-Side Polyfills](https://nextjs.org/docs/basic-features/supported-browsers-features#server-side-polyfills)****
        - ****[Custom Polyfills](https://nextjs.org/docs/basic-features/supported-browsers-features#custom-polyfills)****
        
        > ****[JavaScript Language Features](https://nextjs.org/docs/basic-features/supported-browsers-features#javascript-language-features)****
        > 
        - [Async/await](https://github.com/tc39/ecmascript-asyncawait) (ES2017)
        - [Object Rest/Spread Properties](https://github.com/tc39/proposal-object-rest-spread) (ES2018)
        - [Dynamic `import()`](https://github.com/tc39/proposal-dynamic-import) (ES2020)
        - [Optional Chaining](https://github.com/tc39/proposal-optional-chaining) (ES2020)
        - [Nullish Coalescing](https://github.com/tc39/proposal-nullish-coalescing) (ES2020)
        - [Class Fields](https://github.com/tc39/proposal-class-fields) and [Static Properties](https://github.com/tc39/proposal-static-class-features) (part of stage 3 proposal)
        - and more!
        
        > ****[TypeScript Features](https://nextjs.org/docs/basic-features/supported-browsers-features#typescript-features)****
        > 
        
        > ****[Customizing Babel Config (Advanced)](https://nextjs.org/docs/basic-features/supported-browsers-features#customizing-babel-config-advanced)****
        > 
    - **[Handling Scripts](https://nextjs.org/docs/basic-features/script)(Script Component)**
        
        The Next.js Script component, `[next/script](https://nextjs.org/docs/api-reference/next/script)`, is an extension of the HTML `<script>` element.
        
        It enables developers to set the loading priority of third-party scripts anywhere in their application without needing to append directly to `next/head`, saving developer time while improving loading performance.
        
        > ****[Overview](https://nextjs.org/docs/basic-features/script#overview)****
        > 
        
        웹 사이트는 종종 타사 스크립트를 사용하여 분석, 광고, 고객 지원 위젯 및 동의 관리와 같은 다양한 유형의 기능을 사이트에 포함합니다. 그러나 이로 인해 사용자와 개발자 경험 모두에 영향을 미치는 문제가 발생할 수 있습니다.
        
        일부 타사 스크립트는 로드 성능이 매우 높으며, 특히 렌더 차단 중이고 페이지 컨텐츠 로드를 지연시키는 경우 사용자 환경을 끌어내릴 수 있습니다.
        개발자들은 종종 최적의 로드를 보장하기 위해 애플리케이션에서 타사 스크립트를 배치할 위치를 결정하는 데 어려움을 겪습니다.
        스크립트 구성 요소를 사용하면 개발자가 로드 전략을 최적화하면서 타사 스크립트를 응용 프로그램의 어디에나 쉽게 배치할 수 있습니다.
        
        > ****[Usage](https://nextjs.org/docs/basic-features/script#usage)** `import Script from 'next/script'`
        > 
        - ****[Strategy](https://nextjs.org/docs/basic-features/script#strategy)**
            - `beforeInteractive`: Load before the page is interactive
                - Bot detectors
                - Cookie consent managers
            - `afterInteractive`: (**default**): Load immediately after the page becomes interactive
                - Tag managers
                - Analytics
            - `lazyOnload`: Load during idle time
                - Chat support plugins
                - Social media widgets
        
        > ****[Inline Scripts](https://nextjs.org/docs/basic-features/script#inline-scripts)****
        > 
        - 인라인 스크립트 또는 외부 파일에서 로드되지 않은 스크립트도 스크립트 구성 요소에 의해 지원됩니다. 자바스크립트를 중괄호 안에 넣어 작성할 수 있다.
        - Or by using the `dangerouslySetInnerHTML` property
        - 주의사항
            - Only the `afterInteractive` and `lazyOnload` strategies can be used.
            - • An `id` attribute must be defined in order for Next.js to track and optimize the script.
        
        > ****[Executing Code After Loading (`onLoad`)](https://nextjs.org/docs/basic-features/script#executing-code-after-loading-onload)**
        > 
        - 어떤 서드파티 코드들은 로딩이 끝난후에 불러와질 필요가 있다(인스턴스화 또는 함수실행)
        - If you are loading a script with either `beforeInteractive` or `afterInteractive` as a loading strategy, you can execute code after it has loaded using the `onLoad` property
        - These errors can be handled with the `onError` property
        
        > ****[Additional Attributes](https://nextjs.org/docs/basic-features/script#additional-attributes)****
        > 
        - `nonce` → 논스(nonce)는 블록체인에서 목표값 이하의 블록 해시를 찾기 위해 임시로 사용하는 숫자이다. 넌스, 난스 또는 임시값이라고도 한다.
- **Routing**
    - **[Introduction](https://nextjs.org/docs/routing/introduction)**
        
        Next.js has a file-system based router built on the [concept of pages](https://nextjs.org/docs/basic-features/pages).
        
        > ****[Index routes](https://nextjs.org/docs/routing/introduction#index-routes) e.g.**• `pages/blog/index.js` → `/blog`****
        > 
        
        > ****[Nested routes](https://nextjs.org/docs/routing/introduction#nested-routes) e.g.** • `pages/dashboard/settings/username.js` → `/dashboard/settings/username`
        > 
        
        > ****[Dynamic route segments](https://nextjs.org/docs/routing/introduction#dynamic-route-segments)****
        > 
        - `pages/blog/[slug].js` → `/blog/:slug` (`/blog/hello-world`)
        - `pages/[username]/settings.js` → `/:username/settings` (`/foo/settings`)
        - `pages/post/[...all].js` → `/post/*` (`/post/2020/id/title`)
        
        > ****[Linking between pages](https://nextjs.org/docs/routing/introduction#linking-between-pages)****
        > 
        - A React component called `Link` is provided to do this client-side route transition.
        
        > ****[Linking to dynamic paths](https://nextjs.org/docs/routing/introduction#linking-to-dynamic-paths)****
        > 
        - You can also use interpolation to create the path, which comes in handy for [dynamic route segments](https://nextjs.org/docs/routing/introduction#dynamic-route-segments).
        - Alternatively, using a URL Object
        
        > ****[Injecting the router](https://nextjs.org/docs/routing/introduction#injecting-the-router)****
        > 
        - To access the `[router` object](https://nextjs.org/docs/api-reference/next/router#router-object) in a React component you can use `[useRouter](https://nextjs.org/docs/api-reference/next/router#userouter)` or `[withRouter](https://nextjs.org/docs/api-reference/next/router#withrouter)`. In general we recommend using `[useRouter](https://nextjs.org/docs/api-reference/next/router#userouter)`.
        - 
    - ****Dynamic Routes****
        
        Consider the following page `pages/post/[pid].js`
        
        ```jsx
        import { useRouter } from 'next/router'
        
        const Post = () => {
          const router = useRouter()
          const { pid } = router.query
        
          return <p>Post: {pid}</p>
        }
        
        export default Post
        ```
        
        쿼리에 따른 라우터는 첫번째 순위는 대괄호 내에 들어가 있는 키의 이름이다. 
        
        ex) `/post/abc?pid=123` will have the following `query` object:`{ "pid": "abc" }`
        
        추가되는 것은 query로 추가된다.
        
        ex) `/post/abc?foo=bar` → `{ "foo": "bar", "pid": "abc" }`
        
        > ****[Catch all routes](https://nextjs.org/docs/routing/dynamic-routes#catch-all-routes) :** `pages/post/[...slug].js`
        > 
        
        > ****[Optional catch all routes](https://nextjs.org/docs/routing/dynamic-routes#optional-catch-all-routes) :** `pages/post/[[...slug]].js`  위랑 차이점은 index 포함여부 이건 포함할 수 있음. pages/post 도 가능
        > 
        
        > ****[Caveats](https://nextjs.org/docs/routing/dynamic-routes#caveats) : 경고**
        > 
        - `pages/post/create.js` - Will match `/post/create`
        - `pages/post/[pid].js` - Will match `/post/1`, `/post/abc`, etc. But not `/post/create`
        - `pages/post/[...slug].js` - Will match `/post/1/2`, `/post/a/b/c`, etc. But not `/post/create`, `/post/abc`
        
    - ****Imperatively : 명령조로, 단호하게; 부득이하게****
        - `next/link` 없이도 이용할 수 있다. `next/router` 가 있다.
        
        ```jsx
         import { useRouter } from 'next/router'
        
        export default function ReadMore() {
          const router = useRouter()
        
          return (
            <button onClick={() => router.push('/about')}>
              Click here to read more
            </button>
          )
        }
        ```
        
    - ****Shallow Routing****
        
        Shallow routing allows you to change the URL without running data fetching methods again, that includes `[getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props)`, `[getStaticProps](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)`, and `[getInitialProps](https://nextjs.org/docs/api-reference/data-fetching/get-initial-props)`.
        
        The URL will get updated to `/?counter=10`. and the page won't get replaced, only the state of the route is changed.
        
        ```jsx
        import { useEffect } from 'react'
        import { useRouter } from 'next/router'
        
        // Current URL is '/'
        function Page() {
          const router = useRouter()
        
          useEffect(() => {
            // Always do navigations after the first render
            router.push('/?counter=10', undefined, { shallow: true })
          }, [])
        
          useEffect(() => {
            // The counter changed!
          }, [router.query.counter])
        }
        
        export default Page
        ```
        
        You can also watch for URL changes via `[componentDidUpdate](https://reactjs.org/docs/react-component.html#componentdidupdate)` as shown below:
        
        ```jsx
        componentDidUpdate(prevProps) {
          const { pathname, query } = this.props.router
          // verify props have changed to avoid an infinite loop
          if (query.counter !== prevProps.router.query.counter) {
            // fetch data based on the new query
          }
        }
        ```
        
        현재 페이지의 상태 값 바꾸려고 만든거임 ! `router.push` 의 두번째 인자가 `undefined`
        
        경고 ! 이건 기능은 오직 페이지 내에서만 동작한다. 다른 페이지로 이동할 때는 의미 없다. 
        
- ****API Routes****
    - Introduce
        - [Basic API Routes](https://github.com/vercel/next.js/tree/canary/examples/api-routes)
        - [API Routes with middleware](https://github.com/vercel/next.js/tree/canary/examples/api-routes-middleware)
        - [API Routes with GraphQL](https://github.com/vercel/next.js/tree/canary/examples/api-routes-graphql)
        - [API Routes with REST](https://github.com/vercel/next.js/tree/canary/examples/api-routes-rest)
        - [API Routes with CORS](https://github.com/vercel/next.js/tree/canary/examples/api-routes-cors)
        
        > ****[Use Cases](https://nextjs.org/docs/api-routes/introduction#use-cases)****
        > 
        - Masking the URL of an external service (e.g. `/api/secret` instead of `https://company.com/secret-url`)
        - Using [Environment Variables](https://nextjs.org/docs/basic-features/environment-variables) on the server to securely access external services.
        
        > **[Caveats](https://nextjs.org/docs/api-routes/introduction#caveats)**
        > 
        - API Routes [do not specify CORS headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), meaning they are **same-origin only** by default. You can customize such behavior by wrapping the request handler with the [CORS middleware](https://nextjs.org/docs/api-routes/api-middlewares#connectexpress-middleware-support).
        - API Routes can't be used with `[next export](https://nextjs.org/docs/advanced-features/static-html-export)`
    - ****Dynamic API Routes : [링크랑 비슷함](https://www.notion.so/NextJs-24365c7adba7491d9db15183d57c8edb)**
        
        > ****[Index routes and Dynamic API routes](https://nextjs.org/docs/api-routes/dynamic-api-routes#index-routes-and-dynamic-api-routes)****
        > 
        
        > ****[Catch all API routes](https://nextjs.org/docs/api-routes/dynamic-api-routes#catch-all-api-routes)****
        > 
        - API Routes can be extended to catch all paths by adding three dots (`...`
        ) inside the brackets.
        
        > ****[Optional catch all API routes](https://nextjs.org/docs/api-routes/dynamic-api-routes#optional-catch-all-api-routes)****
        > 
        - Catch all routes can be made optional by including the parameter in double brackets (`[[...slug]]`).
        
        > ****[Caveats](https://nextjs.org/docs/api-routes/dynamic-api-routes#caveats)****
        > 
    - ****API Middlewares****
        
        API routes provide built in middlewares which parse the incoming request (`req`). Those middlewares are:
        
        - `req.cookies` - An object containing the cookies sent by the request. Defaults to `{}`
        - `req.query` - An object containing the [query string](https://en.wikipedia.org/wiki/Query_string). Defaults to `{}`
        - `req.body` - An object containing the body parsed by `content-type`, or `null` if no body was sent
        
        > ****[Custom config](https://nextjs.org/docs/api-routes/api-middlewares#custom-config)****
        > 
        - Every API route can export a `config` object to change the default configs, which are the following
        - 예시 : disabling the automatic `bodyParsing` + `webhook` request
            
            [Securing your webhooks - GitHub Docs](https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks#validating-payloads-from-github)
            
        
        > ****[Connect/Express middleware support](https://nextjs.org/docs/api-routes/api-middlewares#connectexpress-middleware-support)****
        > 
        - You can also use [Connect](https://github.com/senchalabs/connect) compatible middleware.
        
        ```jsx
        async function handler(req, res) {
          // Run the middleware
          await runMiddleware(req, res, cors)
        
          // Rest of the API logic
          res.json({ message: 'Hello Everyone!' })
        }
        ```
        
        > ****[Extending the `req`/`res` objects with TypeScript](https://nextjs.org/docs/api-routes/api-middlewares#extending-the-reqres-objects-with-typescript)**
        > 
        - For better type-safety, it is not recommended to extend the `req`
         and `res` objects. Instead, use functions to work with them.
        - If you can't avoid these objects from being extended, you have to create your own type to include the extra properties
        
    - **[Response Helpers](https://nextjs.org/docs/api-routes/response-helpers)**
        
        The [Server Response object](https://nodejs.org/api/http.html#http_class_http_serverresponse), (often abbreviated as `res`) includes a set of Express.js-like helper methods to improve the developer experience and increase the speed of creating new API endpoints.
        
        - `res.status(code)`
            - - A function to set the status code. `code` must be a valid [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
        - `res.json(body)`
            - - Sends a JSON response. `body` must be a [serializable object](https://developer.mozilla.org/en-US/docs/Glossary/Serialization)
        - `res.send(body)`
            - - Sends the HTTP response. `body` can be a `string`, an `object` or a `Buffer`
        - `res.redirect([status,] path)`
            - - Redirects to a specified path or URL. `status` must be a valid [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). If not specified, `status` defaults to "307" "Temporary redirect".
        
        > ****[Setting the status code of a response](https://nextjs.org/docs/api-routes/response-helpers#setting-the-status-code-of-a-response)****
        > 
        
        > ****[Sending a JSON response](https://nextjs.org/docs/api-routes/response-helpers#sending-a-json-response)****
        > 
        
        > ****[Sending a HTTP response](https://nextjs.org/docs/api-routes/response-helpers#sending-a-http-response)****
        > 
        
        > ****[Redirects to a specified path or URL](https://nextjs.org/docs/api-routes/response-helpers#redirects-to-a-specified-path-or-url)****
        > 
        
        > ****[Adding TypeScript types](https://nextjs.org/docs/api-routes/response-helpers#adding-typescript-types)****
        > 
        
        <aside>
        ❤️‍🔥 결론 : NextJs 를 백엔드처럼 사용하기? 비슷한 질의가 있어서 가져와봄 → next를 백엔드 용도로 쓸 수도 있지만 두 코드를 분리하는게 안정성 측면에서 좋다고 함,,, 굳이 next로 백엔드 설정하지 말 것
        
        [Can NextJS serve as the backend for an app?](https://www.reddit.com/r/reactjs/comments/ktg98v/can_nextjs_serve_as_the_backend_for_an_app/)
        
        </aside>
        
- ****Middleware****
    
    Middleware enables you to use code over configuration.
    
    This gives you full flexibility in Next.js, because you can run code before a request is completed.
    
    - 타입스크립트로만 사용 가능한듯
    - 이것도 백엔드 기능입니다
    
    > ****[Execution Order](https://nextjs.org/docs/middleware#execution-order) : 실행순서**
    > 
    
    → 페이지 별로 미들웨어 설정할 수 있음다.
    
    ```
    - package.json
    - /pages
        index.tsx
        - /about
          _middleware.ts # Will run first
          about.tsx
          - /teams
            _middleware.ts # Will run second
            teams.tsx
    ```
    
- ****Going to Production****
    
    Before taking your Next.js application to production, here are some recommendations to ensure the best user experience.
    
    > **[In General](https://nextjs.org/docs/going-to-production#in-general)**
    > 
    - Use [caching](https://nextjs.org/docs/going-to-production#caching) wherever possible.
    - Ensure your database and backend are deployed in the same region.
    - Aim to ship the least amount of JavaScript possible.
    - Defer loading heavy JavaScript bundles until needed.
    - Ensure [logging](https://nextjs.org/docs/going-to-production#logging) is set up.
    - Ensure [error handling](https://nextjs.org/docs/going-to-production#error-handling) is set up.
    - Configure the [404](https://nextjs.org/docs/advanced-features/custom-error-page#404-page) (Not Found) and [500](https://nextjs.org/docs/advanced-features/custom-error-page#500-page) (Error) pages.
    - Ensure you are [measuring performance](https://nextjs.org/docs/advanced-features/measuring-performance).
    - Run [Lighthouse](https://developers.google.com/web/tools/lighthouse) to check for performance, best practices, accessibility, and SEO. For best results, use a production build of Next.js and use incognito in your browser so results aren't affected by extensions.
    - Review [Supported Browsers and Features](https://nextjs.org/docs/basic-features/supported-browsers-features).
    - Improve performance using:
        - `[next/image` and Automatic Image Optimization](https://nextjs.org/docs/basic-features/image-optimization)
        - [Automatic Font Optimization](https://nextjs.org/docs/basic-features/font-optimization)
        - [Script Optimization](https://nextjs.org/docs/basic-features/script)
    - Improve [loading performance](https://nextjs.org/docs/going-to-production#loading-performance)
    
    > ****[Caching](https://nextjs.org/docs/going-to-production#caching) : 좋으니까 왠만하면 그냥 쓰세요.**
    > 
    
    `Cache-Control` headers set in `next.config.js` will be overwritten in production to ensure that static assets can be cached effectively.
    
    `getServerSideProps` `[getStaticProps](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)` 에서 캐시 또 설정할 수 있음.
    
    <aside>
    ❤️‍🔥 **Note:** Your deployment provider must support edge caching for dynamic responses. If you are self-hosting, you will need to add this logic to the edge yourself using a key/value store. If you are using Vercel, [edge caching works without configuration](https://vercel.com/docs/edge-network/caching).
    
    </aside>
    
    > ****[Reducing JavaScript Size](https://nextjs.org/docs/going-to-production#reducing-javascript-size)****
    > 
    - [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) – Display the size of the imported package inside VSCode.
    - [Package Phobia](https://packagephobia.com/) – Find the cost of adding a new dev dependency to your project.
    - [Bundle Phobia](https://bundlephobia.com/) - Analyze how much a dependency can increase bundle sizes.
    - [Webpack Bundle Analyzer](https://github.com/vercel/next.js/tree/canary/packages/next-bundle-analyzer) – Visualize size of webpack output files with an interactive, zoomable treemap.
    
    > ****[Logging](https://nextjs.org/docs/going-to-production#logging)****
    > 
    - If you want a structured logging package, we recommend [Pino](https://www.npmjs.com/package/pino)
    - If you're using Vercel, there are [pre-built logging integrations](https://vercel.com/integrations#logging) compatible with Next.js.
    
    > ****[Error Handling](https://nextjs.org/docs/going-to-production#error-handling)****
    > 
    - You can also log and track exceptions with a tool like Sentry. [This example](https://github.com/vercel/next.js/tree/canary/examples/with-sentry)
     shows how to catch & report errors on both the client and server-side, using the Sentry SDK for Next.js. There's also a [Sentry integration for Vercel](https://vercel.com/integrations/sentry).
    
    > ****[Loading Performance](https://nextjs.org/docs/going-to-production#loading-performance)****
    > 
    - To improve loading performance, you first need to determine what to measure and how to measure it.
    - If you are not familiar with the metrics of `Core Web Vitals`, review this [blog post](https://vercel.com/blog/core-web-vitals)
     and determine which specific metric/s will be your drivers for loading performance.
        - In the lab, using your own computer or a simulator.
        - In the field, using real-world data from actual visitors.
        - Local, using a test that runs on your device.
        - Remote, using a test that runs in the cloud.
    - Once you are able to measure the loading performance, use the following strategies to improve it iteratively so that you apply one strategy, measure the new performance and continue tweaking until you do not see much improvement. Then, you can move on to the next strategy.
        - Use caching regions that are close to the regions where your database or API is deployed.
        - As described in the [caching](https://nextjs.org/docs/going-to-production#caching) section, use a `stale-while-revalidate` value that will not overload your backend.
        - Use [Incremental Static Regeneration](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration) to reduce the number of requests to your backend.
        - Remove unused JavaScript. Review this [blog post](https://calibreapp.com/blog/bundle-size-optimization) to understand what Core Web Vitals metrics bundle size affects and what strategies you can use to reduce it, such as:
            - Setting up your Code Editor to view import costs and sizes
            - Finding alternative smaller packages
            - Dynamically loading components and dependencies
            - For more in depth information, review this [guide](https://papyrus.dev/@PapyrusBlog/how-we-reduced-next.js-page-size-by-3.5x-and-achieved-a-98-lighthouse-score) and this [performance checklist](https://dev.to/endymion1818/nextjs-performance-checklist-5gjb).
    
- ****Deployment****
    
    Congratulations, you are ready to deploy your Next.js application to production. This document will show how to deploy either managed or self-hosted using the [Next.js Build API](https://nextjs.org/docs/deployment#nextjs-build-api).
    
    > ****[Next.js Build API](https://nextjs.org/docs/deployment#nextjs-build-api)****
    > 
    
    `next build` → This output is generated inside the `.next` folder:
    
    - `.next/static/chunks/pages` – Each JavaScript file inside this folder relates to the route with the same name. For example, `.next/static/chunks/pages/about.js` would be the JavaScript file loaded when viewing the `/about` route in your application
    - `.next/static/media` – Statically imported images from `next/image` are hashed and copied here
    - `.next/static/css` – Global CSS files for all pages in your application
    - `.next/server/pages` – The HTML and JavaScript entry points prerendered from the server. The `.nft.json` files are created when [Output File Tracing](https://nextjs.org/docs/advanced-features/output-file-tracing) is enabled and contain all the file paths that depend on a given page.
    - `.next/server/chunks` – Shared JavaScript chunks used in multiple places throughout your application
    - `.next/cache` – Output for the build cache and cached images, responses, and pages from the Next.js server. Using a cache helps decrease build times and improve performance of loading images
    
    > ****[Managed Next.js with Vercel](https://nextjs.org/docs/deployment#managed-nextjs-with-vercel)****
    > 
    - Persisting cached assets across deployments if unchanged
    - [Immutable deployments](https://vercel.com/features/previews) with a unique URL for every commit
    - [Pages](https://nextjs.org/docs/basic-features/pages) are automatically statically optimized, if possible
    - Assets (JavaScript, CSS, images, fonts) are compressed and served from a [Global Edge Network](https://vercel.com/features/infrastructure)
    - [API Routes](https://nextjs.org/docs/api-routes/introduction) are automatically optimized as isolated [Serverless Functions](https://vercel.com/features/infrastructure) that can scale infinitely
    - [Middleware](https://nextjs.org/docs/middleware) are automatically optimized as [Edge Functions](https://vercel.com/features/edge-functions) that have zero cold starts and boot instantly
        
        > In addition, Vercel provides features like:
        > 
        - Automatic performance monitoring with [Next.js Analytics](https://vercel.com/analytics)
        - Automatic HTTPS and SSL certificates
        - Automatic CI/CD (through GitHub, GitLab, Bitbucket, etc.)
        - Support for [Environment Variables](https://vercel.com/docs/environment-variables)
        - Support for [Custom Domains](https://vercel.com/docs/custom-domains)
        - Support for [Image Optimization](https://nextjs.org/docs/basic-features/image-optimization) with `next/image`
        - Instant global deployments via `git push`
        
        [Deploy a Next.js application to Vercel](https://vercel.com/new/git/external?repository-url=https://github.com/vercel/next.js/tree/canary/examples/hello-world&project-name=hello-world&repository-name=hello-world&utm_source=github.com&utm_medium=referral&utm_campaign=deployment) for free to try it out.
        
    
    > ****[Self-Hosting](https://nextjs.org/docs/deployment#self-hosting)****
    > 
    - ****[Node.js Server](https://nextjs.org/docs/deployment#nodejs-server)****
    - ****[Docker Image](https://nextjs.org/docs/deployment#docker-image)****
    - ****[Static HTML Export](https://nextjs.org/docs/deployment#static-html-export)****
        - follow the directions on our [Static HTML Export documentation](https://nextjs.org/docs/advanced-features/static-html-export), which [has some limitations](https://nextjs.org/docs/advanced-features/static-html-export).
    
    > ****[Automatic Updates](https://nextjs.org/docs/deployment#automatic-updates)****
    >